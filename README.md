# Bilibili-Recommender

**一个基于 Bilibili 用户行为数据与多模态深度学习的个性化视频推荐系统。**

> **声明**：本项目仅用于深度学习算法研究与 Python 全栈开发学习测试，严禁用于任何商业用途或恶意爬取。

## 1. 项目概述 

本项目是一个端到端的推荐系统 Demo，旨在通过调用 Bilibili 网页端 API 获取用户的实时行为数据（观看历史、收藏、投币、点赞等），利用 **Wide&Deep + Attention** 深度学习网络进行实时训练，构建用户的兴趣画像。

在最新版本中，系统完成了从“标签匹配”向**“语义感知与序列预测”**的跨越。通过引入 **NLP (自然语言处理)** 和 **GRU (门控循环单元)** 时序模型，结合工程级的性能优化，实现了毫秒级的推荐响应。

### 核心功能

- **个性化热门精选**：从 B 站热门榜单中，根据模型预测筛选出用户可能感兴趣的视频。
- **兴趣探索推荐**：基于首页推荐流，挖掘非热门但符合用户潜在兴趣的长尾内容。
- **实时推荐指数**：为每个推荐视频计算置信度（Rating），直观展示推荐理由。
- **多模态特征融合**：结合了视频标签、标题语义、UP主特征及用户行为序列。

## 2. 技术细节

### 2.1 用户行为数据获取与预处理

本项目调用 Bilibili 网页 API 获取登录用户的观看、收藏、投币、点赞等行为数据。

- **数据清洗**：对获取的原始 JSON 数据进行清洗，去除无效条目。
- **自动化采集**：相较于传统数据集，系统自动获取用户行为数据提供了无缝的用户体验，并为深度学习模型提供了**多维度特征**（点赞状态、观看进度、交互时间戳等）。
- **[优化] 极速数据链路**：重构了数据获取逻辑，移除了对视频详情页的串行爬取 ($O(N)$)，转为利用 NLP 模型直接处理列表页的标题信息，将网络 I/O 复杂度降至 $O(1)$，**单次推荐耗时从 10s+ 降至 <0.5s**。

### 2.2 前后端架构

采用 **Flask + Jinja2** 的轻量级 Web 方案，并进行了工程化改造。

- **交互流程**：
  1. 后端生成登录二维码 -> 前端展示。
  2. 用户 App 扫码 -> 后端获取 Cookie 并持久化。
  3. 点击“推荐” -> 异步请求后端 API -> 返回 JSON -> 前端渲染卡片。
- **[优化] 全局单例模式**：后端实现了 `Recommender` 类的单例模式与模型热启动（Hot Start）。系统启动时自动加载预训练权重 (`.h5`)，避免了每次请求都重新构建计算图的巨大开销。
- **[优化] 异步绘图后端**：配置 `matplotlib.use('Agg')`，解决了 Flask 主线程绘图导致的阻塞与并发报错问题。

### 2.3 推荐模型：多模态 Wide&Deep + GRU

本系统采用 **Wide&Deep** 架构作为基础，结合 **Attention** 机制、**NLP** 技术和 **序列化建模**，以解决传统协同过滤在冷启动和语义理解上的不足。

#### **A. 特征工程 (Feature Engineering)**

模型输入由原来的三维扩展为五维多模态输入，分为三类特征：

1. **内容语义特征 (Semantic)**：

   - **NLP 标题处理**：引入 `Jieba` 分词，构建 Title Embedding 层，通过 Global Average Pooling 提取标题的深层语义。这解决了新视频 Tag 缺失导致的冷启动问题。
   - **标签 (Tags)**：通过可扩展 Embedding 层处理，结合 **Attention 机制** 动态捕捉核心标签，降低噪声标签的干扰。
   - **UP主 (Author)**：将作者 ID 映射为稠密向量，捕捉对特定创作者的偏好。

2. **时序行为特征 (Sequential)**：

   - **历史序列 (History)**：将用户历史观看记录按时间戳 (`view_at`) 排序，输入 **GRU (门控循环单元)** 层。这使得模型能够捕捉用户兴趣随时间的动态演变（例如：用户近期从“学习区”转向了“游戏区”）。

3. **内容质量特征 (Quality)**：

   - 基于播放量、点赞数、收藏数计算显式质量分，直接输入 Wide 部分。

   - 质量评分公式：

     

     $$\text{Score} = \alpha \times \left( \frac{\text{Likes}}{\log{(\text{Views +1})}} \right)+ \beta \times \left( \frac{\text{Favs}}{\log{(\text{Views +1})}} \right) + \gamma \times \log(\text{Views}+1)$$

4. **用户兴趣标签 (Label)**：

   - 根据用户交互行为计算置信度，作为训练的目标值：

     

     $$\text{Interest} = \max \left( \text{isliked} + \text{isfaved}, \frac{\text{progress}}{\text{duration}}\right)$$

#### **B. 模型构建 (Model Architecture)**

提取特征后，分别经过 Deep 部分和 Wide 部分：

- **Deep 部分 (语义与泛化)**：

  - 主要处理稀疏、高维的内容与时序特征。
  - 输入层将 Tags Embedding、Author Embedding、**Title NLP Vector** 与 **History GRU State** 进行拼接 (Concatenate)。
  - 通过 3 层全连接层 (Dense Layers) 进行非线性变换，挖掘高阶特征交互。

- **Wide 部分 (记忆与相关性)**：

  - 主要处理显式的内容质量特征。

  - 通过一个简单的线性层直接学习内容质量分数和用户兴趣之间的强关联：

    $$\text{wide\_output} = \text{quality\_score} \times w + b$$

- **输出层**：

  - 将 Wide 部分和 Deep 部分的输出连接，通过一个 Sigmoid 激活函数的全连接层得到最终的预测概率 (0~1)。

- 训练优化：考虑到正负样本不平衡（点赞/收藏样本远少于普通浏览），在训练时引入了类别权重：

  class_weight.compute_class_weight(class_weight='balanced', ...)

### 2.4 前端交互与体验升级

- **Bilibili UI 设计**：引入响应式 Grid 卡片布局与 B 站品牌色系（粉/蓝），提供原生级的视觉体验。
- **防盗链突破**：通过注入 `<meta name="referrer" content="no-referrer">`，完美解决 B 站图片 403 裂图问题，实现前端直连 CDN。
- **健壮性设计**：重构 JS 渲染逻辑，引入空值熔断与 Loading 状态管理，杜绝因数据缺失导致的页面白屏。

## 3. 性能对比

| **维度**         | **原始版本 (Baseline)**  | **当前版本 (Optimized)**           | **提升幅度**      |
| ---------------- | ------------------------ | ---------------------------------- | ----------------- |
| **推荐逻辑**     | 仅基于标签匹配           | **多模态 (Tags + NLP + Sequence)** | 模型表达能力质变  |
| **API 响应耗时** | 5.0s ~ 15.0s             | **< 0.5s**                         | **速度提升 10x+** |
| **资源消耗**     | 每次请求重新训练         | **单例常驻，增量更新**             | 资源利用率优化    |
| **网络开销**     | $O(N)$ (需 N 次详情请求) | **$O(1)$ (仅 1 次列表请求)**       | 网络 IO 最小化    |
| **冷启动能力**   | 弱 (强依赖 Tags)         | **强 (基于标题语义)**              | 泛化能力增强      |

## 4. 环境配置及运行

### 环境准备

项目基于 Python 3.9.20，依赖库请见 `requirements.txt`。

```bash
# 1. 创建并激活虚拟环境 (推荐)
python -m venv .venv
# Windows:
.venv\Scripts\activate
# Linux/Mac:
source .venv/bin/activate

# 2. 安装依赖
pip install -r requirements.txt
```

### 运行系统

在项目根目录下运行启动脚本：

```bash
python ./run.py
# 如果遇到无响应情况，可尝试：
# python -m flask run --port 8345
```

启动成功后，点击命令行显示的链接（通常为 `http://127.0.0.1:8345`）即可访问前端页面。

